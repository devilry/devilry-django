{% load i18n %}
{% load cradmin_legacy_icon_tags %}

<script type="module">

    class CSRFToken {
        constructor () {
            this.csrftoken = this._getCookie('csrftoken');
        }

        _getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
    }

    const TOOLBAR_KEYBOARD_MAP = {
        'ctrl': false,      // CTRL (Windows)
        'Meta': false,      // CMD (macOS)
        'Enter': false,     // Enter
        'Shift': false,     // Shift
        'b': false,         // CTRL or CMD + b: bold
        'i': false,         // CTRL or CMD + i: italic
        'k': false,         // CTRL or CMD + k: link
        '7': false,         // CTRL or CMD + Shift + 7: Ordered list
        '8': false,         // CTRL or CMD + Shift + 8: Unordered list
    };
    const TOOLBAR_HEADING = 'heading';
    const TOOLBAR_BOLD = 'bold';
    const TOOLBAR_ITALIC = 'italic';
    const TOOLBAR_LINK = 'link';
    const TOOLBAR_CODE_INLINE = 'codeInline';
    const TOOLBAR_CODE_BLOCK = 'codeBlock';
    const TOOLBAR_UNORDERED_LIST = 'unorderedList';
    const TOOLBAR_ORDERED_LIST = 'orderedList';
    const ORDERED_LIST_REGEX = '^(\\s*)([0-9]*\\.\\s)';
    const UNORDERED_LIST_REGEX = '^(\\s*)(\\*\\s)';

    class DevilryCommentEditor extends HTMLElement {
        constructor () {
            super();

            this.attrLabelText = this.getAttribute('labelText');
            this.attrTextareaName = this.getAttribute('name');
            this.attrTextareaValue = this.getAttribute('value');
            this.attrTextareaPlaceholder = this.getAttribute('placeholder');
            this.attrHelpText = this.getAttribute('helpText');
            this.attrMarkdownGuideLinkUrl = this.getAttribute('markdownGuideLinkUrl');
            this.attrMarkdownGuideLinkText = this.getAttribute('markdownGuideLinkText');
            this.attrMarkdownPreviewConfig = JSON.parse(this.getAttribute('markdownPreviewConfig'));
            this.attrToolbarConfig = JSON.parse(this.getAttribute('toolbarConfig'));

            this.previewActive = false;
        }

        get elementId () {
            return `id_${this.attrTextareaName}`;
        }

        connectedCallback () {
            this.renderEditor();
            this.addToolbarOptionEventListeners();
            this.addToolbarKeyboardShortcutEvents();
            this.addPreviewToggleEventListener();
        }

        get _previewToggleButtonText () {
            if (this.previewActive) {
                return this.attrMarkdownPreviewConfig.previewActiveButtonText;
            }
            return this.attrMarkdownPreviewConfig.editorActiveButtonText;
        }

        _getPreviewSection () {
            if (!this.attrMarkdownPreviewConfig.enabled) {
                return '';
            }
            return `
            <button 
                id="${this.elementId}_preview_markdown_button"
                type="button"
                title="Preview the rendered markdown"
                class="btn btn-default devilry-comment-editor-toolbar__option"
            >
                ${this._previewToggleButtonText}
            </button>
            <div id="${this.elementId}_comment_editor_preview_section" class="devilry-comment-editor-preview--display-none"></div>
            `;
        }

        get _tooltipMetaKeyForPlatform () {
            return this._isMac ? 'Cmd' : 'Ctrl'
        }

        /**
         * Renders the HTML for the editor.
         */
        renderEditor () {
            const commentEditor = new DOMParser().parseFromString(`
                <div>
                    ${this._getPreviewSection()}
                    <div id="${this.elementId}_comment_editor_section" class="devilry-comment-editor">
                        <div class="devilry-comment-editor-toolbar" aria-hidden="true">
                            <button
                                id="${this.elementId}_toolbar_option_heading"
                                type="button"
                                title="${this.attrToolbarConfig.heading.tooltip}"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'h3' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_bold"
                                type="button"
                                title="${this.attrToolbarConfig.bold.tooltip}, ${this._tooltipMetaKeyForPlatform}+b"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'bold' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_italic"
                                type="button"
                                title="${this.attrToolbarConfig.italic.tooltip}, ${this._tooltipMetaKeyForPlatform}+i"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'italic' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_link"
                                type="button"
                                title="${this.attrToolbarConfig.link.tooltip}, ${this._tooltipMetaKeyForPlatform}+k"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'link' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_code_inline"
                                type="button"
                                title="${this.attrToolbarConfig.codeInline.tooltip}, ${this._tooltipMetaKeyForPlatform}+e"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'codeblock' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_code_block"
                                type="button"
                                title="${this.attrToolbarConfig.codeBlock.tooltip}"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'codeblock' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_ordered_list"
                                type="button"
                                title="${this.attrToolbarConfig.orderedList.tooltip}, ${this._tooltipMetaKeyForPlatform}+Shift+7"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                                ${this.previewActive ? 'disabled': ''}
                            >
                                <span class="{% cradmin_icon 'list-ol' %}"></span>
                            </button>
                            <button
                                id="${this.elementId}_toolbar_option_unordered_list"
                                type="button"
                                title="${this.attrToolbarConfig.unorderedList.tooltip}, ${this._tooltipMetaKeyForPlatform}+Shift+8"
                                class="btn btn-default devilry-comment-editor-toolbar__option"
                            >
                                <span class="{% cradmin_icon 'list-ul' %}"></span>
                            </button>
                        </div>
                        <label for="${this.elementId}" class="screenreader-only">${this.attrLabelText}</label>
                        <div class="devilry-comment-editor__textarea">
                            <textarea
                                id="${this.elementId}"
                                cols="40"
                                rows="10"
                                class="devilry-comment-editor-textarea form-control"
                                placeholder="${this.attrTextareaPlaceholder}"
                                name="${this.attrTextareaName}"
                                aria-describedby="${this.elementId}_help">${this.attrTextareaValue}</textarea>
                            <div class="devilry-comment-editor-textarea--copy" aria-hidden="true"></div>
                        </div>
                        <div class="devilry-comment-editor devilry-comment-editor__example-help">
                            <p id="${this.elementId}_help">
                                ${this.attrHelpText}
                                <a href="${this.attrMarkdownGuideLinkUrl}" target='_blank'>
                                    ${this.attrMarkdownGuideLinkText}
                                </a>
                            </p>
                        </div>
                    </div>
                <div>
            `, 'text/html').body.firstChild;
            this.appendChild(commentEditor)
        }

        _fetchAndInjectRenderedMarkdown () {
            if (!this.attrMarkdownPreviewConfig.enabled) {
                return;
            }
            const previewArea = document.getElementById(`${this.elementId}_comment_editor_preview_section`);
            const textArea = this.textArea;
            fetch(this.attrMarkdownPreviewConfig.apiUrl, {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'X-CSRFToken': new CSRFToken().csrftoken
                },
                body: JSON.stringify({'markdown_text': textArea.value})
            })
            .then(response => response.json())
            .then((responseData) => {
                previewArea.innerHTML = responseData['markdown_result'];
            })
            .catch((error) => {
                console.error(error)
            });
        }

        addPreviewToggleEventListener () {
            if (!this.attrMarkdownPreviewConfig.enabled) {
                return;
            }
            document.getElementById(`${this.elementId}_preview_markdown_button`)
                .addEventListener('click', () => {
                    const textArea = this.textArea;
                    if (!textArea.value) {
                        return;
                    }
                    this.previewActive = !this.previewActive;
                    const previewAreaClasses = document.getElementById(`${this.elementId}_comment_editor_preview_section`).classList;
                    const editorAreaClasses = document.getElementById(`${this.elementId}_comment_editor_section`).classList;
                    if (this.previewActive) {
                        editorAreaClasses.remove('devilry-comment-editor');
                        editorAreaClasses.add('devilry-comment-editor--display-none');
                        previewAreaClasses.remove('devilry-comment-editor-preview--display-none');
                        previewAreaClasses.add('devilry-comment-editor-preview');
                        this._fetchAndInjectRenderedMarkdown();
                    } else {
                        previewAreaClasses.remove('devilry-comment-editor-preview');
                        previewAreaClasses.add('devilry-comment-editor-preview--display-none');
                        editorAreaClasses.remove('devilry-comment-editor--display-none');
                        editorAreaClasses.add('devilry-comment-editor');
                    }
                    const previewToggleButton = document.getElementById(`${this.elementId}_preview_markdown_button`);
                    previewToggleButton.innerHTML = this._previewToggleButtonText;
                });
        }

        /**
         * Add event-listeners to toolbar buttons.
         * 
         * Each event-listener ends up calling the `insertAtCursor` with 
         * options according to which toolbar markdown option was pressed.
         */
        addToolbarOptionEventListeners () {
            document.getElementById(`${this.elementId}_toolbar_option_heading`)
                .addEventListener('click', () => {
                    this.toolbarEventActionHeading();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_bold`)
                .addEventListener('click', () => {
                    this.toolbarEventActionBold();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_italic`)
                .addEventListener('click', () => {
                    this.toolbarEventActionItalic();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_link`)
                .addEventListener('click', () => {
                    this.toolbarEventActionLink();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_inline`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeInline();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_block`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeBlock();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_unordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionUnorderedList();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_ordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionOrderedList();
                }, false);
        }

        get _isMac () {
            return window.navigator.platform.toUpperCase().startsWith('MAC');
        }

        /**
         * Add keyboard-shortcuts for toolbar actions.
         */
        addToolbarKeyboardShortcutEvents () {
            // Prevents default behaviour and stops event propagation.
            function _performToolbarKeyboardShortcutAction (event, actionFunction, preventDefault = true) {
                if (preventDefault) {
                    event.preventDefault();
                }
                event.stopPropagation();
                actionFunction();
            }

            // Add key down event listener.
            document.onkeydown = (keyDownEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    TOOLBAR_KEYBOARD_MAP[keyDownEvent.key] = true;
                    
                    // Handle MacOS vs everything else.
                    let controlKey = 'Control';
                    if (this._isMac) {
                        controlKey = 'Meta';
                    }

                    if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['b']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionBold();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['i']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionItalic();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['k']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionLink();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['e']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionCodeInline();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['7']) {
                            _performToolbarKeyboardShortcutAction(
                                keyDownEvent, () => {this.toolbarEventActionOrderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['8']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionUnorderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP['Enter']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent,
                            () => {
                                const cursorStartLine = this._getCursorLine();
                                if (cursorStartLine.match(UNORDERED_LIST_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST, event);
                                } else if (cursorStartLine.match(ORDERED_LIST_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST, event);
                                }
                            },
                            false);
                    }
                }
            };

            // Add key up event listener.
            document.onkeyup = (keyUpEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    Object.keys(TOOLBAR_KEYBOARD_MAP).forEach(key => {
                        TOOLBAR_KEYBOARD_MAP[key] = false;
                    });
                }
            };
        }

        toolbarEventActionHeading () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_HEADING, '\n### ', '', this.attrToolbarConfig.heading.placeholderText);
        }

        toolbarEventActionBold () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_BOLD, '**', '**', this.attrToolbarConfig.bold.placeholderText);
        }

        toolbarEventActionItalic () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_ITALIC, '_', '_', this.attrToolbarConfig.italic.placeholderText);
        }

        toolbarEventActionLink () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_LINK, '[', '](url)', this.attrToolbarConfig.link.placeholderText);
        }

         toolbarEventActionCodeInline () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_INLINE, '`', '`', this.attrToolbarConfig.codeInline.placeholderText);
        }

         toolbarEventActionCodeBlock () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_BLOCK, '```', '\n\n```', this.attrToolbarConfig.codeBlock.placeholderText);
        }

         toolbarEventActionUnorderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST);
        }

         toolbarEventActionOrderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST);
        }

        get textArea () {
            return document.getElementById(`${this.elementId}`);
        }

        /**
         * Inserts markdown-tag at cursor-position.
         * 
         * Inserts markdown-tag at cursor-position, by adding a opening and closing 
         * markdown-tag around the selected text (if any). When the markdown-tag is inserted, 
         * and the value for the text-area is updated, the cursor is placed at the end of the 
         * tagged text (including the closing markdown-tag).
         * 
         * @param {String} type         Type of markdown-tag.
         * @param {String} openingTag   The opening markdown-tag. E.g. for links where the full markdown tag is "[]()", the opening-tag whould be "(".
         * @param {String} closingTag   The closing markdown-tag. E.g. for links where the full markdown tag is "[]()", the closing-tag whould be "]()".
         * @param {String} placeholder  This is the placeholder text inserted between the opening and closing markdown tags if no text is selected.
         */
        insertBasicMarkdownAtCursor (type, openingTag, closingTag, placeholder) {
            if (![TOOLBAR_HEADING, TOOLBAR_BOLD, TOOLBAR_ITALIC, TOOLBAR_LINK, TOOLBAR_CODE_INLINE, TOOLBAR_CODE_BLOCK].includes(type)) {
                throw Error(`Type "${type}" not supported.`);
            }

            const textArea = this.textArea;
            const initialSelectionStart = textArea.selectionStart;
            const initialSelectionEnd = textArea.selectionEnd;

            let selectedText = textArea.value.substring(textArea.selectionStart, textArea.selectionEnd);

            if (!selectedText) {
                selectedText = placeholder || '';
            }
            const taggedText = openingTag + selectedText + closingTag
            textArea.value = textArea.value.substring(0, initialSelectionStart) + taggedText + textArea.value.substring(textArea.selectionEnd, textArea.value.length)

            // Places focus to the marked text as the selected range.
            textArea.focus()
            textArea.selectionStart = initialSelectionStart + openingTag.length;
            textArea.selectionEnd = initialSelectionEnd + openingTag.length;
        }

        /**
         * Insert ordered/unorderd list for selected text.
         * 
         * @param {String} type                 Type of markdown-tag.
         * @param {Object} enterKeyPressEvent   Enter key pressed event. Defaults to null. 
         *                                      If this is not null, then keypress is handled 
         *                                      by continuing the list on the current line.
         */
         insertMarkdownListAtCursor (type, enterKeyPressEvent = null) {
            if (![TOOLBAR_UNORDERED_LIST, TOOLBAR_ORDERED_LIST].includes(type)) {
                throw Error(`Type list-type "${type}" not supported.`);
            }

            const textArea = this.textArea;
            const cursorStartIndex = textArea.value.substring(0, textArea.selectionStart).split('\n').length - 1;
            const cursorEndIndex = textArea.value.substring(0, textArea.selectionEnd).split('\n').length - 1;
            const cursorStartEndIndexDiff = cursorEndIndex - cursorStartIndex;

            let textAreaLineArray = textArea.value.split('\n');
            let newTextAreaValue = '';
            let newSelectionStart = null;
            let newSelectionEnd = null;

            if (enterKeyPressEvent) {
                // Continue list on "Enter"-keypress.
                //
                // Continue the list by parsing the current line to find out 
                // if the current line is a numbered or a bulleted list. The 
                // next line will then be continued with the appropriate tag, 
                // where a numbered tag will be incremented based on the value 
                // of the current line. The array is then updated with the new 
                // numbered/bulleted line.
                //
                // The list will NOT be continued if the current line is an empty 
                // numbered or bulleted line. In this case, the will be "reset", and 
                // cursor is moved to the start of the line.
                //
                // The list will NOT be continued if a range of text is selected. In 
                // this case the default "Enter"-keypress behaviour will be applied 
                // instead.
                if (textArea.selectionStart !== textArea.selectionEnd) {
                    return;
                }
                event.preventDefault();

                const cursorLine = this._getCursorLine();
                let listTag = '';

                // Set the tag to be used.
                // If the tag is empty, i.e has not been set, this means that 
                // the current list has no content after the tag. This will 
                // result in the line being reset.
                if (type === TOOLBAR_ORDERED_LIST) {
                    const match = cursorLine.match(`${ORDERED_LIST_REGEX}(.+)`);
                    if (match) {
                        listTag = match[1] + (parseInt(match[2]) + 1) + '. ';
                    }
                } else {
                    const match = cursorLine.match(`${UNORDERED_LIST_REGEX}(.+)`);
                    if (match) {
                        listTag = match[1] + match[2];
                    }
                }
                
                // This is the cursor position after the new line has been inserted with offset 
                // relative to where the cursor is currently at, and will be used set the cursor 
                // to the correct position when the new list-line has been added.
                let cursorPositionWithOffset = null;

                // Build the line array based on whether the new line to be inserted should continue 
                // the list or "reset" it.
                if (listTag) {
                    textAreaLineArray = [
                        ...textAreaLineArray.slice(0, cursorStartIndex + 1),
                        listTag,
                        ...textAreaLineArray.slice(cursorStartIndex + 1)
                    ];
                    cursorPositionWithOffset = textArea.selectionStart + listTag.length + 1; 
                } else {
                    // Current list-line has no content, remove content and set 
                    // cursor to line start.
                    textAreaLineArray = [
                        ...textAreaLineArray.slice(0, cursorStartIndex),
                        listTag,
                        ...textAreaLineArray.slice(cursorStartIndex + 1)
                    ];
                    cursorPositionWithOffset = textArea.selectionStart - cursorLine.length; 
                }

                // Set new cursor position.
                newSelectionStart = cursorPositionWithOffset;
                newSelectionEnd = cursorPositionWithOffset;
            } else {
                // Convert selected lines to list.
                //
                // The line(s) of the selected range of text will be converted to 
                // a list, where each line receives the appropriate list-tag (OL/UL).
                let markdownListTag = type === TOOLBAR_UNORDERED_LIST ? '* ' : '1. ';
                let orderedListCounter = 1;

                // Isolate the selected area, and add tags.
                const selectedAreaChunk = [];
                for (let i = cursorStartIndex; i <= cursorEndIndex; i++) {
                    if (type === TOOLBAR_ORDERED_LIST) {
                        markdownListTag = `${orderedListCounter}. `;
                        orderedListCounter++;
                    }
                    selectedAreaChunk.push(
                        `${markdownListTag}${textAreaLineArray[i]}`
                    );
                }

                // Update the array where the selected range has been tagged, and set cursor positions.
                textAreaLineArray = [
                    ...textAreaLineArray.slice(0, cursorStartIndex),
                    ...cursorStartIndex > 0 && textAreaLineArray[cursorStartIndex - 1].match('\.') ? [''] : [],
                    ...selectedAreaChunk,
                    ...cursorEndIndex < textAreaLineArray.length - 1 && textAreaLineArray[cursorEndIndex + 1].match('\.') ? [''] : [],
                    ...textAreaLineArray.slice(cursorEndIndex + 1)
                ];
                if (cursorStartEndIndexDiff === 0) {
                    newSelectionStart = textArea.selectionStart + markdownListTag.length;
                    newSelectionEnd = textArea.selectionEnd + markdownListTag.length;
                } else {
                    newSelectionStart = textArea.selectionStart + markdownListTag.length;
                    newSelectionEnd = textArea.selectionEnd + (cursorStartEndIndexDiff * markdownListTag.length) + markdownListTag.length;
                }
            }

            // Rebuild the textarea value from the textAreaLineArray.
            // Append a newline character to each line except the last.
            const arrayLength = textAreaLineArray.length - 1;
            for (let i = 0; i < arrayLength; i++) {
                newTextAreaValue += textAreaLineArray[i] + '\n';
            }
            newTextAreaValue += textAreaLineArray[arrayLength];

            // Update textarea.
            textArea.value = newTextAreaValue;
            textArea.focus();
            if (newSelectionStart) {
                textArea.selectionStart = newSelectionStart;
            }
            if (newSelectionEnd) {
                textArea.selectionEnd = newSelectionEnd;
            }
        }

        _getCursorLine () {
            const textArea = this.textArea;
            return textArea.value.substring(0, textArea.selectionStart).split('\n').slice(-1)[0];
        }
    }

    window.customElements.define('devilry-comment-editor', DevilryCommentEditor);
</script>

<devilry-comment-editor {{ attributes|safe }}></devilry-comment-editor>
