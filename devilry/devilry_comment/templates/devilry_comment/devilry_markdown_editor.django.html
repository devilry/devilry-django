{% load i18n %}
{% load cradmin_legacy_icon_tags %}

<script type="module">

    const TOOLBAR_KEYBOARD_MAP = {
        'ctrl': false,      // CTRL (Windows)
        'Meta': false,      // CMD (macOS)
        'Enter': false,     // Enter
        'Shift': false,     // Shift
        'b': false,         // CTRL or CMD + b: bold
        'i': false,         // CTRL or CMD + i: italic
        'k': false,         // CTRL or CMD + k: link
        '7': false,         // CTRL or CMD + Shift + 7: Ordered list
        '8': false,         // CTRL or CMD + Shift + 8: Unordered list
    };
    const TOOLBAR_HEADING = 'heading';
    const TOOLBAR_BOLD = 'bold';
    const TOOLBAR_ITALIC = 'italic';
    const TOOLBAR_LINK = 'link';
    const TOOLBAR_CODE_INLINE = 'codeInline';
    const TOOLBAR_CODE_BLOCK = 'codeBlock';
    const TOOLBAR_UNORDERED_LIST = 'unorderedList';
    const TOOLBAR_ORDERED_LIST = 'orderedList';
    const OL_REGEX = '^(\\s*)([0-9]*\\.\\s)';
    const UL_REGEX = '^(\\s*)(\\*\\s)';

    class DevilryCommentEditor extends HTMLElement {
        constructor () {
            super();

            this.attrLabelText = this.getAttribute('labelText');
            this.attrTextareaName = this.getAttribute('name');
            this.attrTextareaValue = this.getAttribute('value');
            this.attrHelpText = this.getAttribute('helpText');
            this.attrMarkdownGuideLinkUrl = this.getAttribute('markdownGuideLinkUrl');
            this.attrMarkdownGuideLinkText = this.getAttribute('markdownGuideLinkText');
            this.attrToolbarConfig = JSON.parse(this.getAttribute('toolbarConfig'));
        }

        get elementId () {
            return `id_${this.attrTextareaName}`;
        }

        connectedCallback () {
            this.renderEditor();
            this.addToolbarOptionEventListeners();
            this.addToolbarKeyboardShortcutEvents();
        }

        /**
         * Renders the HTML for the editor.
         */
        renderEditor () {
            const commentEditor = new DOMParser().parseFromString(`
                <div class="devilry-comment-editor">
                    <div class="devilry-comment-editor-toolbar" aria-hidden="true">
                        <button
                            id="${this.elementId}_toolbar_option_heading"
                            type="button"
                            title="${this.attrToolbarConfig.heading.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'h3' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_bold"
                            type="button"
                            title="${this.attrToolbarConfig.bold.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'bold' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_italic"
                            type="button"
                            title="${this.attrToolbarConfig.italic.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'italic' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_link"
                            type="button"
                            title="${this.attrToolbarConfig.link.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'link' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_code_inline"
                            type="button"
                            title="${this.attrToolbarConfig.codeInline.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'codeblock' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_code_block"
                            type="button"
                            title="${this.attrToolbarConfig.codeBlock.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'codeblock' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_unordered_list"
                            type="button"
                            title="${this.attrToolbarConfig.unorderedList.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'list-ul' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_ordered_list"
                            type="button"
                            title="${this.attrToolbarConfig.orderedList.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'list-ol' %}"></span>
                        </button>
                    </div>
                    <label for="${this.elementId}" class="screenreader-only">${this.attrLabelText}</label>
                    <div class="devilry-comment-editor__textarea">
                        <textarea
                            id="${this.elementId}"
                            cols="40"
                            rows="10"
                            class="devilry-comment-editor-textarea form-control"
                            name="${this.attrTextareaName}"
                            aria-describedby="${this.elementId}_help">${this.attrTextareaValue}</textarea>
                        <div class="devilry-comment-editor-textarea--copy" aria-hidden="true"></div>
                    </div>
                    <div class="devilry-comment-editor devilry-comment-editor__example-help">
                        <p id="${this.elementId}_help">
                            ${this.attrHelpText}
                            <a href="${this.attrMarkdownGuideLinkUrl}" target='_blank'>
                                ${this.attrMarkdownGuideLinkText}
                            </a>
                        </p>
                    </div>
                </div>
            `, 'text/html').body.firstChild;
            this.appendChild(commentEditor)
        }

        /**
         * Add event-listeners to toolbar buttons.
         * 
         * Each event-listener ends up calling the `insertAtCursor` with 
         * options according to which toolbar markdown option was pressed.
         */
        addToolbarOptionEventListeners () {
            document.getElementById(`${this.elementId}_toolbar_option_heading`)
                .addEventListener('click', () => {
                    this.toolbarEventActionHeading();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_bold`)
                .addEventListener('click', () => {
                    this.toolbarEventActionBold();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_italic`)
                .addEventListener('click', () => {
                    this.toolbarEventActionItalic();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_link`)
                .addEventListener('click', () => {
                    this.toolbarEventActionLink();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_inline`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeInline();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_block`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeBlock();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_unordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionUnorderedList();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_ordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionOrderedList();
                }, false);
        }

        /**
         * Add keyboard-shortcuts for toolbar actions.
         */
        addToolbarKeyboardShortcutEvents () {
            // Prevents default behaviour and stops event propagation.
            function _performToolbarKeyboardShortcutAction (event, actionFunction, preventDefault = true) {
                if (preventDefault) {
                    event.preventDefault();
                }
                event.stopPropagation();
                actionFunction();
            }

            // Add key down event listener.
            document.onkeydown = (keyDownEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    TOOLBAR_KEYBOARD_MAP[keyDownEvent.key] = true;
                    
                    // Handle MacOS vs everything else.
                    let controlKey = 'Control';
                    if (window.navigator.platform.toUpperCase().startsWith('MAC')) {
                        controlKey = 'Meta';
                    }

                    if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['b']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionBold();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['i']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionItalic();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['k']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionLink();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['e']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionCodeInline();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['7']) {
                            _performToolbarKeyboardShortcutAction(
                                keyDownEvent, () => {this.toolbarEventActionOrderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['8']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionUnorderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP['Enter']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent,
                            () => {
                                const cursorStartLine = this._getCursorLine();
                                if (cursorStartLine.match(UL_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST, event);
                                } else if (cursorStartLine.match(OL_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST, event);
                                }
                            },
                            false);
                    }
                }
            };

            // Add key up event listener.
            document.onkeyup = (keyUpEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    Object.keys(TOOLBAR_KEYBOARD_MAP).forEach(key => {
                        TOOLBAR_KEYBOARD_MAP[key] = false;
                    });
                }
            };
        }

        toolbarEventActionHeading () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_HEADING, '\n### ', '', this.attrToolbarConfig.heading.placeholderText);
        }

        toolbarEventActionBold () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_BOLD, '**', '**', this.attrToolbarConfig.bold.placeholderText);
        }

        toolbarEventActionItalic () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_ITALIC, '_', '_', this.attrToolbarConfig.italic.placeholderText);
        }

        toolbarEventActionLink () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_LINK, '[', '](url)', this.attrToolbarConfig.link.placeholderText);
        }

         toolbarEventActionCodeInline () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_INLINE, '`', '`', this.attrToolbarConfig.codeInline.placeholderText);
        }

         toolbarEventActionCodeBlock () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_BLOCK, '```', '\n\n```', this.attrToolbarConfig.codeBlock.placeholderText);
        }

         toolbarEventActionUnorderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST);
        }

         toolbarEventActionOrderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST);
        }

        /**
         * Inserts markdown-tag at cursor-position.
         * 
         * Inserts markdown-tag at cursor-position, by adding a opening and closing 
         * markdown-tag around the selected text (if any). When the markdown-tag is inserted, 
         * and the value for the text-area is updated, the cursor is placed at the end of the 
         * tagged text (including the closing markdown-tag).
         * 
         * @param {String} type         Type of markdown-tag.
         * @param {String} openingTag   The opening markdown-tag. E.g. for links where the full markdown tag is "[]()", the opening-tag whould be "(".
         * @param {String} closingTag   The closing markdown-tag. E.g. for links where the full markdown tag is "[]()", the closing-tag whould be "]()".
         * @param {String} placeholder  This is the placeholder text inserted between the opening and closing markdown tags if no text is selected.
         */
        insertBasicMarkdownAtCursor (type, openingTag, closingTag, placeholder) {
            if (![TOOLBAR_HEADING, TOOLBAR_BOLD, TOOLBAR_ITALIC, TOOLBAR_LINK, TOOLBAR_CODE_INLINE, TOOLBAR_CODE_BLOCK].includes(type)) {
                throw Error(`Type "${type}" not supported.`);
            }

            const textArea = document.getElementById(`${this.elementId}`);

            let selectedText = textArea.value.substring(textArea.selectionStart, textArea.selectionEnd);

            if (!selectedText) {
                selectedText = placeholder || '';
            }
            const taggedText = openingTag + selectedText + closingTag
            textArea.value = textArea.value.substring(0, textArea.selectionStart) + taggedText + textArea.value.substring(textArea.selectionEnd, textArea.value.length)

            // Places focus to the marked text as the selected range.
            textArea.focus()
            textArea.selectionStart = textArea.selectionStart + openingTag.length;
            textArea.selectionEnd = textArea.selectionStart + selectedText.length;
        }

        /**
         * Lists requires special handling for inserting markdown tags, and does not quite fit 
         * the general solution for simple tags that simply wrap the selected text.
         * 
         * @param {String} type                 Type of markdown-tag.
         * @param {Object} enterKeyPressEvent   Enter key pressed event. Defaults to null. 
         *                                      If this is not null, then keypress is handled 
         *                                      by continuing the list on the current line.
         */
         insertMarkdownListAtCursor (type, enterKeyPressEvent = null) {
            if (![TOOLBAR_UNORDERED_LIST, TOOLBAR_ORDERED_LIST].includes(type)) {
                throw Error(`Type list-type "${type}" not supported.`);
            }

            const textArea = document.getElementById(`${this.elementId}`);
            const cursorStartIndex = textArea.value.substring(0, textArea.selectionStart).split('\n').length - 1;
            const cursorEndIndex = textArea.value.substring(0, textArea.selectionEnd).split('\n').length - 1;
            const cursorStartEndIndexDiff = cursorEndIndex - cursorStartIndex;

            let textAreaLineArray = textArea.value.split('\n');
            let newTextAreaValue = '';
            let newSelectionStart = null;
            let newSelectionEnd = null;

            if (enterKeyPressEvent) {
                // Continue list on "Enter"-keypress.
                //
                // Continue the list by parsing the current line to find out 
                // if the current line is a OL or UL. Then next line will then 
                // continued with the appropriate tag, where OL tag will be 
                // incremented from the value of the current line. The array is 
                // then updated with the new OL/UL line inserted.
                //
                // The list will NOT be continued if a range of text is selected. In 
                // this case the default "Enter"-keypress behaviour will be applied 
                // instead.
                if (textArea.selectionStart !== textArea.selectionEnd) {
                    return;
                }
                event.preventDefault();

                // Set tag to be used.
                const cursorLine = this._getCursorLine();
                let listTag = '';
                if (type === TOOLBAR_ORDERED_LIST) {
                    const match = cursorLine.match(OL_REGEX);
                    listTag = match[1] + (parseInt(match[2]) + 1) + '. ';
                } else {
                    const match = cursorLine.match(UL_REGEX);
                    listTag = match[1] + match[2];
                }

                // Update array with tag on new line, and set cursor position.
                textAreaLineArray = [
                    ...textAreaLineArray.slice(0, cursorStartIndex + 1),
                    listTag,
                    ...textAreaLineArray.slice(cursorStartIndex + 1)
                ];
                newSelectionStart = textArea.selectionStart + listTag.length + 1;
                newSelectionEnd = textArea.selectionStart + listTag.length + 1;

            } else {
                // Convert selected lines to list.
                //
                // The line(s) of the selected range of text will be converted to 
                // a list, where each line receives the appropriate list-tag (OL/UL).
                let markdownListTag = type === TOOLBAR_UNORDERED_LIST ? '* ' : '1. ';
                let orderedListCounter = 1;

                // Isolate the selected area, and add tags.
                const selectedAreaChunk = [];
                for (let i = cursorStartIndex; i <= cursorEndIndex; i++) {
                    if (type === TOOLBAR_ORDERED_LIST) {
                        markdownListTag = `${orderedListCounter}. `;
                        orderedListCounter++;
                    }
                    selectedAreaChunk.push(
                        `${markdownListTag}${textAreaLineArray[i]}`
                    );
                }

                // Update the array where the selected range has been tagged, and set cursor positions.
                textAreaLineArray = [
                    ...textAreaLineArray.slice(0, cursorStartIndex),
                    ...cursorStartIndex > 0 && textAreaLineArray[cursorStartIndex - 1].match('\.') ? [''] : [],
                    ...selectedAreaChunk,
                    ...cursorEndIndex < textAreaLineArray.length - 1 && textAreaLineArray[cursorEndIndex + 1].match('\.') ? [''] : [],
                    ...textAreaLineArray.slice(cursorEndIndex + 1)
                ];
                if (cursorStartEndIndexDiff === 0) {
                    newSelectionStart = textArea.selectionStart + markdownListTag.length;
                    newSelectionEnd = textArea.selectionEnd + markdownListTag.length;
                } else {
                    newSelectionStart = textArea.selectionStart + markdownListTag.length;
                    newSelectionEnd = textArea.selectionEnd + (cursorStartEndIndexDiff * markdownListTag.length) + markdownListTag.length;
                }
            }

            // Rebuild the textarea value from the textAreaLineArray.
            // Append a newline character to each line except the last.
            const arrayLength = textAreaLineArray.length - 1;
            for (let i = 0; i < arrayLength; i++) {
                newTextAreaValue += textAreaLineArray[i] + '\n';
            }
            newTextAreaValue += textAreaLineArray[arrayLength];

            // Update textarea.
            textArea.value = newTextAreaValue;
            textArea.focus();
            if (newSelectionStart) {
                textArea.selectionStart = newSelectionStart;
            }
            if (newSelectionEnd) {
                textArea.selectionEnd = newSelectionEnd;
            }
        }

        _getCursorLine () {
            const textArea = document.getElementById(`${this.elementId}`);
            return textArea.value.substring(0, textArea.selectionStart).split('\n').slice(-1)[0];
        }
    }

    window.customElements.define('devilry-comment-editor', DevilryCommentEditor);
</script>

<devilry-comment-editor {{ attributes|safe }}></devilry-comment-editor>
