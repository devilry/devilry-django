{% load i18n %}
{% load cradmin_legacy_icon_tags %}

<script type="module">

    const TOOLBAR_KEYBOARD_MAP = {
        'ctrl': false,      // CTRL (Windows)
        'Meta': false,      // CMD (macOS)
        'Enter': false,     // Enter
        'Shift': false,     // Shift
        'b': false,         // CTRL or CMD + b: bold
        'i': false,         // CTRL or CMD + i: italic
        'k': false,         // CTRL or CMD + k: link
        '7': false,         // CTRL or CMD + Shift + 7: Ordered list
        '8': false,         // CTRL or CMD + Shift + 8: Unordered list
    };
    const TOOLBAR_HEADING = 'heading';
    const TOOLBAR_BOLD = 'bold';
    const TOOLBAR_ITALIC = 'italic';
    const TOOLBAR_LINK = 'link';
    const TOOLBAR_CODE_INLINE = 'codeInline';
    const TOOLBAR_CODE_BLOCK = 'codeBlock';
    const TOOLBAR_UNORDERED_LIST = 'unorderedList';
    const TOOLBAR_ORDERED_LIST = 'orderedList';
    const OL_REGEX = '^(\\s*)([0-9]*\\.\\s)';
    const UL_REGEX = '^(\\s*)(\\*\\s)';

    class DevilryCommentEditor extends HTMLElement {
        constructor () {
            super();

            this.attrLabelText = this.getAttribute('labelText');
            this.attrTextareaName = this.getAttribute('name');
            this.attrTextareaValue = this.getAttribute('value');
            this.attrHelpText = this.getAttribute('helpText');
            this.attrMarkdownGuideLinkUrl = this.getAttribute('markdownGuideLinkUrl');
            this.attrMarkdownGuideLinkText = this.getAttribute('markdownGuideLinkText');
            this.attrToolbarConfig = JSON.parse(this.getAttribute('toolbarConfig'));
        }

        get elementId () {
            return `id_${this.attrTextareaName}`;
        }

        connectedCallback () {
            this.renderEditor();
            this.addToolbarOptionEventListeners();
            this.addToolbarKeyboardShortcutEvents();
        }

        /**
         * Renders the HTML for the editor.
         */
        renderEditor () {
            const commentEditor = new DOMParser().parseFromString(`
                <div class="devilry-comment-editor">
                    <div class="devilry-comment-editor-toolbar" aria-hidden="true">
                        <button
                            id="${this.elementId}_toolbar_option_heading"
                            type="button"
                            title="${this.attrToolbarConfig.heading.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'h3' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_bold"
                            type="button"
                            title="${this.attrToolbarConfig.bold.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'bold' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_italic"
                            type="button"
                            title="${this.attrToolbarConfig.italic.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'italic' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_link"
                            type="button"
                            title="${this.attrToolbarConfig.link.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'link' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_code_inline"
                            type="button"
                            title="${this.attrToolbarConfig.codeInline.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'codeblock' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_code_block"
                            type="button"
                            title="${this.attrToolbarConfig.codeBlock.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'codeblock' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_unordered_list"
                            type="button"
                            title="${this.attrToolbarConfig.unorderedList.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'list-ul' %}"></span>
                        </button>
                        <button
                            id="${this.elementId}_toolbar_option_ordered_list"
                            type="button"
                            title="${this.attrToolbarConfig.orderedList.tooltip}"
                            class="btn btn-default devilry-comment-editor-toolbar__option"
                        >
                            <span class="{% cradmin_icon 'list-ol' %}"></span>
                        </button>
                    </div>
                    <label for="${this.elementId}" class="screenreader-only">${this.attrLabelText}</label>
                    <div class="devilry-comment-editor__textarea">
                        <textarea
                            id="${this.elementId}"
                            cols="40"
                            rows="10"
                            class="devilry-comment-editor-textarea form-control"
                            name="${this.attrTextareaName}"
                            aria-describedby="${this.elementId}_help">${this.attrTextareaValue}</textarea>
                        <div class="devilry-comment-editor-textarea--copy" aria-hidden="true"></div>
                    </div>
                    <div class="devilry-comment-editor devilry-comment-editor__example-help">
                        <p id="${this.elementId}_help">
                            ${this.attrHelpText}
                            <a href="${this.attrMarkdownGuideLinkUrl}" target='_blank'>
                                ${this.attrMarkdownGuideLinkText}
                            </a>
                        </p>
                    </div>
                </div>
            `, 'text/html').body.firstChild;
            this.appendChild(commentEditor)
        }

        /**
         * Add event-listeners to toolbar buttons.
         * 
         * Each event-listener ends up calling the `insertAtCursor` with 
         * options according to which toolbar markdown option was pressed.
         */
        addToolbarOptionEventListeners () {
            document.getElementById(`${this.elementId}_toolbar_option_heading`)
                .addEventListener('click', () => {
                    this.toolbarEventActionHeading();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_bold`)
                .addEventListener('click', () => {
                    this.toolbarEventActionBold();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_italic`)
                .addEventListener('click', () => {
                    this.toolbarEventActionItalic();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_link`)
                .addEventListener('click', () => {
                    this.toolbarEventActionLink();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_inline`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeInline();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_code_block`)
                .addEventListener('click', () => {
                    this.toolbarEventActionCodeBlock();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_unordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionUnorderedList();
                }, false);
            document.getElementById(`${this.elementId}_toolbar_option_ordered_list`)
                .addEventListener('click', () => {
                    this.toolbarEventActionOrderedList();
                }, false);
        }

        /**
         * Add keyboard-shortcuts for toolbar actions.
         */
        addToolbarKeyboardShortcutEvents () {
            // Prevents default behaviour and stops event propagation.
            function _performToolbarKeyboardShortcutAction (event, actionFunction, preventDefault = true) {
                if (preventDefault) {
                    event.preventDefault();
                }
                event.stopPropagation();
                actionFunction();
            }

            // Add key down event listener.
            document.onkeydown = (keyDownEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    TOOLBAR_KEYBOARD_MAP[keyDownEvent.key] = true;
                    
                    // Handle MacOS vs everything else.
                    let controlKey = 'Control';
                    if (window.navigator.platform.toUpperCase().startsWith('MAC')) {
                        controlKey = 'Meta';
                    }

                    if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['b']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionBold();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['i']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionItalic();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['k']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionLink();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['e']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionCodeInline();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['7']) {
                            _performToolbarKeyboardShortcutAction(
                                keyDownEvent, () => {this.toolbarEventActionOrderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP[controlKey] && TOOLBAR_KEYBOARD_MAP['Shift'] && TOOLBAR_KEYBOARD_MAP['8']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent, () => {this.toolbarEventActionUnorderedList();});
                    } else if (TOOLBAR_KEYBOARD_MAP['Enter']) {
                        _performToolbarKeyboardShortcutAction(
                            keyDownEvent,
                            () => {
                                const cursorStartLine = this._getCursorLine();
                                if (cursorStartLine.match(UL_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST, event);
                                } else if (cursorStartLine.match(OL_REGEX)) {
                                    this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST, event);
                                }
                            },
                            false);
                    }
                }
            };

            // Add key up event listener.
            document.onkeyup = (keyUpEvent) => {
                if (document.activeElement.id === `${this.elementId}`) {
                    Object.keys(TOOLBAR_KEYBOARD_MAP).forEach(key => {
                        TOOLBAR_KEYBOARD_MAP[key] = false;
                    });
                }
            };
        }

        toolbarEventActionHeading () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_HEADING, '\n### ', '', this.attrToolbarConfig.heading.placeholderText);
        }

        toolbarEventActionBold () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_BOLD, '**', '**', this.attrToolbarConfig.bold.placeholderText);
        }

        toolbarEventActionItalic () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_ITALIC, '_', '_', this.attrToolbarConfig.italic.placeholderText);
        }

        toolbarEventActionLink () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_LINK, '[', '](url)', this.attrToolbarConfig.link.placeholderText);
        }

         toolbarEventActionCodeInline () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_INLINE, '`', '`', this.attrToolbarConfig.codeInline.placeholderText);
        }

         toolbarEventActionCodeBlock () {
            this.insertBasicMarkdownAtCursor(TOOLBAR_CODE_BLOCK, '```', '\n\n```', this.attrToolbarConfig.codeBlock.placeholderText);
        }

         toolbarEventActionUnorderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_UNORDERED_LIST);
        }

         toolbarEventActionOrderedList () {
            this.insertMarkdownListAtCursor(TOOLBAR_ORDERED_LIST);
        }

        /**
         * Inserts markdown-tag at cursor-position.
         * 
         * Inserts markdown-tag at cursor-position, by adding a opening and closing 
         * markdown-tag around the selected text (if any). When the markdown-tag is inserted, 
         * and the value for the text-area is updated, the cursor is placed at the end of the 
         * tagged text (including the closing markdown-tag).
         * 
         * @param {String} type         Type of markdown-tag.
         * @param {String} openingTag   The opening markdown-tag. E.g. for links where the full markdown tag is "[]()", the opening-tag whould be "(".
         * @param {String} closingTag   The closing markdown-tag. E.g. for links where the full markdown tag is "[]()", the closing-tag whould be "]()".
         * @param {String} placeholder  This is the placeholder text inserted between the opening and closing markdown tags if no text is selected.
         */
        insertBasicMarkdownAtCursor (type, openingTag, closingTag, placeholder) {
            if (![TOOLBAR_HEADING, TOOLBAR_BOLD, TOOLBAR_ITALIC, TOOLBAR_LINK, TOOLBAR_CODE_INLINE, TOOLBAR_CODE_BLOCK].includes(type)) {
                throw Error(`Type "${type}" not supported.`);
            }

            // Get textarea to manipulate
            const textArea = document.getElementById(`${this.elementId}`);

            // Get start and end position of the cursor.
            const cursorStart = textArea.selectionStart;
            const cursorEnd = textArea.selectionEnd;

            // Get text marked in range. This is text, if any, is inserted 
            // between the openingTag and the closingTag.
            let selectedText = textArea.value.substring(cursorStart, cursorEnd);

            if (!selectedText) {
                selectedText = placeholder || '';
            }
            const taggedText = openingTag + selectedText + closingTag
            textArea.value = textArea.value.substring(0, cursorStart) + taggedText + textArea.value.substring(cursorEnd, textArea.value.length)

            // Places focus to the marked text as the selected range.
            textArea.focus()
            textArea.selectionStart = cursorStart + openingTag.length;
            textArea.selectionEnd = textArea.selectionStart + selectedText.length;
        }

        /**
         * Lists requires special handling for inserting markdown tags, and does not quite fit 
         * the general solution for simple tags that simply wrap the selected text.
         * 
         * @param {String} type                 Type of markdown-tag.
         * @param {Object} enterKeyPressEvent   Enter key pressed event. Defaults to null. 
         *                                      If this is not null, then keypress is handled 
         *                                      by continuing the list on the current line.
         */
         insertMarkdownListAtCursor (type, enterKeyPressEvent = null) {
            if (![TOOLBAR_UNORDERED_LIST, TOOLBAR_ORDERED_LIST].includes(type)) {
                throw Error(`Type list-type "${type}" not supported.`);
            }

            // Get textarea to manipulate
            const textArea = document.getElementById(`${this.elementId}`);

            // New textarea value with list tags inserted
            let newTextAreaValue = '';

            // Get start and end position of the cursor.
            const cursorStart = textArea.selectionStart;
            const cursorEnd = textArea.selectionEnd;
            let newSelectionStart = null;
            let newSelectionEnd = null;

            // Get the textarea value as an array split on lines.
            // This array will be updated in-place, and the end be 
            // converted back to a string and set as the textarea value.
            let textAreaLineArray = textArea.value.split('\n');
            for (let i = 0; i < textAreaLineArray.length; i++) {
                if (i !== textAreaLineArray.length - 1 ) {
                    textAreaLineArray[i] = textAreaLineArray[i] + '\n';    
                }
            }

            // Get the indexes of which line the start-cursor and the end-cursor is placed.
            const cursorStartIndex = textArea.value.substring(0, cursorStart).split('\n').length - 1;
            const cursorEndIndex = textArea.value.substring(0, cursorEnd).split('\n').length - 1;

            // Get diff between start index and end index.
            const cursorStartEndIndexDiff = cursorEndIndex - cursorStartIndex;

            if (enterKeyPressEvent) {
                // Continue list on enter key-press.

                // If multiple lines are selected, continuation of 
                // list is not performed.
                if (cursorStartEndIndexDiff !== 0) {
                    return;
                }
                event.preventDefault();

                // Create insertion value for the new inserted line.
                // This will keep all spaces at the start until the line 
                // tag. If the line-tag is a number, it will be incremented, 
                // and for unordered lists the tag will be kept as is.
                const cursorLine = this._getCursorLine();
                let listTag = '';
                if (type === TOOLBAR_ORDERED_LIST) {
                    const match = cursorLine.match(OL_REGEX);
                    const nextOrderNum = parseInt(match[2]) + 1;
                    listTag = match[1] + nextOrderNum + '. ';
                } else {
                    const match = cursorLine.match(UL_REGEX);
                    listTag = match[1] + match[2];
                }

                textAreaLineArray = [
                    ...textAreaLineArray.slice(0, cursorStartIndex + 1),
                    '\n' + listTag,
                    ...textAreaLineArray.slice(cursorStartIndex + 1)
                ];
            } else {
                // Convert selected lines to list.
                let markdownListTag = type === TOOLBAR_UNORDERED_LIST ? '* ' : '1. ';
                let orderedListCounter = 1;

                // Isolate the selected area, and add tags.
                const selectedAreaChunk = [];
                for (let i = cursorStartIndex; i <= cursorEndIndex; i++) {
                    if (type === TOOLBAR_ORDERED_LIST) {
                        markdownListTag = `${orderedListCounter}. `;
                        orderedListCounter++;
                    }
                    selectedAreaChunk.push(
                        `${markdownListTag}${textAreaLineArray[i]}`
                    );
                }

                // Reinsert the tagged selected area.
                // If the line above the tagged area has content, add a newline. 
                // Same for line below the tagged area, if any content add a newline 
                // to the end of the tagged area.
                textAreaLineArray = [
                    ...textAreaLineArray.slice(0, cursorStartIndex),
                    cursorStartIndex > 0 && textAreaLineArray[cursorStartIndex - 1].match('\.') ? '\n' : '',
                    ...selectedAreaChunk,
                    cursorEndIndex < textAreaLineArray.length - 1 && textAreaLineArray[cursorEndIndex + 1].match('\.') ? '\n' : '',
                    ...textAreaLineArray.slice(cursorEndIndex + 1)
                ];

                if (cursorStartEndIndexDiff === 0) {
                    newSelectionStart = cursorStart + markdownListTag.length;
                    newSelectionEnd = cursorEnd + markdownListTag.length;
                } else {
                    newSelectionStart = cursorStart + markdownListTag.length;
                    newSelectionEnd = cursorEnd + (cursorStartEndIndexDiff * markdownListTag.length) + markdownListTag.length;
                }
            }
            for (let i = 0; i < textAreaLineArray.length; i++) {
                newTextAreaValue += textAreaLineArray[i];
            }
            textArea.value = newTextAreaValue;
            textArea.focus();
            if (newSelectionStart) {
                textArea.selectionStart = newSelectionStart;
            }
            if (newSelectionEnd) {
                textArea.selectionEnd = newSelectionEnd;
            }
        }

        _getCursorLine () {
            const textArea = document.getElementById(`${this.elementId}`);
            const cursorStart = textArea.selectionStart;
            return textArea.value.substring(0, cursorStart).split('\n').slice(-1)[0];
        }
    }

    window.customElements.define('devilry-comment-editor', DevilryCommentEditor);
</script>

<devilry-comment-editor {{ attributes|safe }}></devilry-comment-editor>
